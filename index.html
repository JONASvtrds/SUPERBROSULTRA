<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Super Bros Ultra - Chat Edition</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; background: #000; overflow: hidden; 
            font-family: 'Press Start 2P', cursive;
            user-select: none;
            -webkit-user-select: none;
        }

        /* CONTAINER DO JOGO */
        #game-container {
            position: relative;
            width: 100vw; height: 100vh;
            background: #5c94fc; 
        }

        canvas { 
            width: 100%; height: 100%; 
            image-rendering: pixelated; 
            display: block; 
        }

        /* UI LAYER */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.92); z-index: 50;
        }
        
        /* HUD */
        .hud {
            position: absolute; top: 20px; left: 20px; width: calc(100% - 40px);
            display: flex; justify-content: space-between;
            color: white; text-shadow: 3px 3px 0 #000; pointer-events: none;
            z-index: 10; text-transform: uppercase; font-size: 18px; line-height: 1.5;
        }

        .lives-box {
            position: absolute; top: 70px; left: 20px;
            color: white; text-shadow: 2px 2px 0 #000; z-index: 10; font-size: 14px;
        }

        /* CHAT MULTIPLAYER (NOVO) */
        #chat-ui {
            position: absolute; bottom: 20px; left: 20px;
            width: 300px; height: 200px;
            display: flex; flex-direction: column;
            z-index: 100;
            pointer-events: auto; /* Permite clicar */
        }
        #chat-messages {
            flex-grow: 1; overflow-y: auto;
            background: rgba(0,0,0,0.5);
            color: white; font-size: 10px; padding: 5px;
            margin-bottom: 5px; border: 2px solid white;
            text-shadow: 1px 1px 0 #000;
            scrollbar-width: none;
        }
        #chat-input {
            background: rgba(0,0,0,0.7); border: 2px solid white;
            color: white; font-family: inherit; font-size: 10px;
            padding: 5px; outline: none;
        }
        .chat-msg { margin-bottom: 4px; }
        .chat-p1 { color: #ff5555; }
        .chat-p2 { color: #55ff55; }

        .hint-box {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: #fff; padding: 15px 25px;
            border-radius: 20px; border: 2px solid white; font-size: 10px;
            pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 15;
        }
        .hint-box.visible { opacity: 1; }

        /* CONTROLES VIRTUAIS */
        #btn-fire {
            position: absolute; bottom: 60px; right: 40px;
            width: 70px; height: 70px; background: rgba(255, 60, 0, 0.7);
            border: 4px solid white; border-radius: 50%;
            color: white; font-family: inherit; font-size: 10px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 40; transition: 0.1s;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #btn-fire:active { background: rgba(255, 0, 0, 1); transform: scale(0.90); }

        .hidden { display: none !important; }

        /* ESTILOS DE MENU E O CHAPÉU (NOVO) */
        h1 { 
            color: #ff3333; text-shadow: 5px 5px 0 #000; 
            font-size: 3.5vw; margin-bottom: 30px; text-align: center; 
            position: relative;
        }

        /* PIXEL ART HAT (CSS PURO) */
        .hat-decoration {
            position: absolute;
            top: -45px; /* Posição acima do ULTRA */
            right: 10px; /* Ajuste horizontal */
            width: 5px; height: 5px; /* Tamanho do pixel */
            background: transparent;
            /* Box Shadow desenha o chapéu pixel por pixel */
            box-shadow: 
                15px 0 #ff0000, 20px 0 #ff0000, 25px 0 #ff0000, 30px 0 #ff0000, 35px 0 #ff0000,
                10px 5px #ff0000, 15px 5px #ff0000, 20px 5px #ff0000, 25px 5px #ff0000, 30px 5px #ff0000, 35px 5px #ff0000, 40px 5px #ff0000,
                10px 10px #ff0000, 15px 10px #ff0000, 20px 10px #ff0000, 25px 10px #ff0000, 30px 10px #ff0000, 35px 10px #ff0000, 40px 10px #ff0000, 45px 10px #ff0000,
                5px 15px #ff0000, 10px 15px #ff0000, 15px 15px #ff0000, 20px 15px #ff0000, 25px 15px #ff0000, 30px 15px #ff0000, 35px 15px #ff0000, 40px 15px #ff0000, 45px 15px #ff0000, 50px 15px #ff0000;
        }
        
        button.menu-btn {
            font-family: inherit; background: transparent; color: white;
            border: 4px solid white; padding: 18px; margin: 10px;
            cursor: pointer; transition: 0.2s; width: 350px; text-transform: uppercase; font-size: 14px;
        }
        button.menu-btn:hover { background: #ff3333; transform: scale(1.05); border-color: #ff3333; color: #fff; }
        
        input.menu-input { padding: 15px; font-family: inherit; text-align: center; margin-bottom: 15px; width: 300px; font-size: 14px; background: #fff; border: none; }
        
        /* TELA DE RESULTADO */
        .result-screen { background: rgba(0,0,0,0.95); color: #fff; text-align: center; }
        .result-title { font-size: 30px; color: #ffcc00; margin-bottom: 20px; text-shadow: 2px 2px 0 #000; }
        .waiting-text { animation: blink 1.5s infinite; color: #aaa; font-size: 12px; margin-top: 10px; }

        /* MENU DE CONTROLES */
        #menu-controls { align-items: center; }
        .controls-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
            background: rgba(0,0,0,0.8); padding: 30px; border: 2px solid white;
            margin-bottom: 20px; text-align: left;
        }
        .key-row { display: flex; align-items: center; justify-content: space-between; font-size: 12px; color: #ddd; }
        .key-box { background: #333; border: 2px solid #aaa; padding: 5px 10px; color: #fff; font-weight: bold; margin-right: 15px; }

        @keyframes blink { 0% {opacity:1;} 50% {opacity:0.3;} 100% {opacity:1;} }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="ctx"></canvas>

    <div id="hud" class="hidden hud">
        <div>MARIO<br><span id="score-val">000000</span></div>
        <div style="text-align:center">WORLD<br>1-1</div>
        <div style="text-align:right">TIME<br><span id="time-val">400</span></div>
    </div>
    <div id="lives-hud" class="hidden lives-box">LIVES: <span id="lives-val">5</span></div>

    <div id="chat-ui" class="hidden">
        <div id="chat-messages">
            <div class="chat-msg" style="color:#aaa">Chat do Sistema P2P Pronto.</div>
        </div>
        <input type="text" id="chat-input" placeholder="Digite e Enter..." onkeydown="Chat.handleInput(event)">
    </div>

    <div id="btn-fire" class="hidden" onmousedown="Game.fireAction()" ontouchstart="Game.fireAction()">FIRE</div>

    <div id="yoshi-hint" class="hint-box">APERTE 'E' PARA SAIR DO YOSHI</div>

    <div id="screen-result" class="ui-layer hidden result-screen">
        <div id="result-msg" class="result-title">COURSE CLEAR!</div>
        <p id="result-sub">OBRIGADO POR JOGAR!</p>
        <div id="wait-msg" class="waiting-text hidden">AGUARDANDO O JOGADOR 2...</div>
        <br>
        <button id="btn-restart" class="menu-btn" onclick="location.reload()">JOGAR NOVAMENTE</button>
    </div>

    <div id="menu-main" class="ui-layer">
        <h1>
            SUPER BROS ULTRA
            <div class="hat-decoration"></div> </h1>
        <button class="menu-btn" onclick="Game.start('single')">1 PLAYER</button>
        <button class="menu-btn" onclick="Menu.showMulti()">2 PLAYERS (P2P)</button>
        <button class="menu-btn" onclick="Menu.showControls()">CONTROLES</button>
    </div>

    <div id="menu-controls-screen" class="ui-layer hidden">
        <h2 style="color:#ffcc00; margin-bottom:20px;">CONTROLES</h2>
        <div class="controls-grid">
            <div class="key-row"><span class="key-box">W / SETA CIMA</span> <span>PULAR / SUBIR</span></div>
            <div class="key-row"><span class="key-box">A / SETA ESQ</span> <span>MOVER ESQUERDA</span></div>
            <div class="key-row"><span class="key-box">S / SETA BAIXO</span> <span>AGACHAR / DESCER</span></div>
            <div class="key-row"><span class="key-box">D / SETA DIR</span> <span>MOVER DIREITA</span></div>
            <div class="key-row"><span class="key-box">ESPAÇO</span> <span>PULAR (NO AR = PULO DUPLO)</span></div>
            <div class="key-row"><span class="key-box">SHIFT</span> <span>CORRER / ATIRAR FOGO</span></div>
            <div class="key-row"><span class="key-box">E</span> <span>DESCER DO YOSHI</span></div>
            <div class="key-row"><span class="key-box">ENTER</span> <span>ENVIAR CHAT</span></div>
        </div>
        <button class="menu-btn" onclick="Menu.hideControls()">VOLTAR</button>
    </div>

    <div id="menu-multi" class="ui-layer hidden">
        <h2 style="color:#ffcc00; margin-bottom: 20px;">MULTIPLAYER P2P</h2>
        <div id="p2p-loading">Conectando ao servidor...</div>
        
        <div id="p2p-ready" class="hidden" style="text-align: center;">
            <p style="font-size:10px; color:#ccc; margin-bottom:5px;">SEU ID (HOST):</p>
            <div style="display:flex; justify-content:center; align-items:center;">
                <input type="text" id="my-id" class="menu-input" readonly onclick="this.select()">
                <button class="menu-btn" style="width:auto; padding:12px; font-size:10px; margin-left:10px;" onclick="Menu.copyId()">COPIAR</button>
            </div>
            
            <div style="margin: 25px 0; border-top:1px dashed #555; width:100%"></div>

            <p style="font-size:10px; color:#ccc; margin-bottom:5px;">ID DO AMIGO (CLIENT):</p>
            <input type="text" id="friend-id" class="menu-input" placeholder="Cole o ID do amigo aqui">
            <br>
            <button class="menu-btn" onclick="Network.connect()" style="background:#00aa00; border-color:#00aa00">ENTRAR NO JOGO</button>
        </div>
        <button class="menu-btn" onclick="location.reload()" style="margin-top:20px; width:200px; font-size:12px">VOLTAR</button>
    </div>
</div>

<script>
/**
 * ==========================================
 * 1. ASSETS
 * ==========================================
 */
const PALETTE = {
    _: 'rgba(0,0,0,0)', 
    r: '#d22020', R: '#8b0000', s: '#ffcc99', 
    b: '#4e2e15', B: '#000000', o: '#2244cc', O: '#112288', 
    g: '#00aa00', G: '#006600', y: '#ffcc00', Y: '#cdaa00', 
    w: '#ffffff', e: '#ffaaaa', k: '#ffbca5', K: '#d66b46', 
    c: '#a0a0a0', C: '#606060', d: '#400000'
};

const SPRITES = {
    mario_idle: ["_____RRRRR______","____RRRRRRRRR___","____bbbssb______","___bbbsbbsbb____","___bbbsbbsbb____","___bbssssbb_____","_____ssss_______","____ooRRo_______","___ooooRRo______","___ooooRRo______","__bbbooRRoobb___","__bbboooOoobb___","__bb_oooo__bb___","_____oooo_______","_____bbbb_______","____bb__bb______"],
    mario_run:  ["_____RRRRR______","____RRRRRRRRR___","____bbbssb______","___bbbsbbsbb____","___bbbsbbsbb____","___bbssssbb_____","_____ssss_______","____ooRRo_______","___ooooRRo______","__bbbooRRoobb___","__bbboooOoobb___","_____oooo_______","____bb__bb______","___bb____bb_____","_____________.__","________________"],
    mario_jump: ["________RRRRR___","_______RRRRRRRRR","_______bbbssb___","______bbbsbbsbb_","______bbbsbbsbb_","______bbssssbb__","________ssss____","____bb_ooRRo____","____bbooooRRo___","_____oooooRRo___","_____oooooOo____","______oooo______","_______bb_______","______bb________","_____bb_________","________________"],
    brick:      ["KKKkKKKkKKKkKKKk","KkkkkkkBKkkkkkkB","KkkkkkkBKkkkkkkB","BBBBBBBBBBBBBBBB","KkkBKkkkkkkBKkkk","KkkBKkkkkkkBKkkk","KkkBKkkkkkkBKkkk","BBBBBBBBBBBBBBBB","KkkkkkkBKkkkkkkB","KkkkkkkBKkkkkkkB","BBBBBBBBBBBBBBBB","KKKkKKKkKKKkKKKk","KKKkKKKkKKKkKKKk","KkkkkkkBKkkkkkkB","KkkkkkkBKkkkkkkB","BBBBBBBBBBBBBBBB"],
    qblock:     ["YYYYYYYYYYYYYYYY","YyyyyyyyyyyyyyyB","YyBBBByyyyBBBByB","YyByyByyyyByyByB","YyByyByyyyByyByB","YyBBBByyyyBBBByB","YyyyyyyyyyyyyyyB","YyyyyyBBBBByyyyB","YyyyyyByyByyyyyB","YyyyyyyBBBxyyyyB","YyyyyyyyByyyyyyB","YyyyyyyyByyyyyyB","YyyyyyyyByyyyyyB","YyyyyyyBBBxyyyyB","YyyyyyyyyyyyyyyB","BBBBBBBBBBBBBBBB"],
    goomba:     ["______BBBB______","_____BkkkkB_____","____BkkkkkkB____","___BkkkkkkkkB___","___BkBkkkkBkB___","___BkBkkkkBkB___","__BkkkBBBBkkkB__","__BkkkkkkkkkkB__","__BkkkkkkkkkkB__","___BkkkkkkkkB___","____BBBBBBBB____","___BkB____BkB___","___BBB____BBB___","________________","________________","________________"],
    mushroom:   ["_______BB_______","_____BBkkBB_____","____BkRRRRkB____","___BkRRwwRRkB___","___BkRRwwRRkB___","___BkRRRRRRkB____","____BkRRRRkB____","_____BBkkBB_____","_____BssssB_____","____BssssssB____","____BssssssB____","____BssssssB____","_____BssssB_____","______BBBB______","________________","________________"],
    flower:     ["______BBBB______","_____BrrrRB_____","____BrrwwrRB____","___BrrwyywrRB___","___BrwyGGywrB___","___BrwyGGywrB___","___BrrwyywrRB____","____BrrwwrRB____","_____BrrrRB_____","______BGGHB_____","______BGGHB_____","_____BGGGHB_____","_____BGGGHB_____","____BGGGGGHB____","____BBBBBBBB____","________________"],
    fireball:   ["_____BBBB_______","____ByyyyB______","___ByyffyyB_____","___ByffffyB_____","___ByyffyyB_____","____ByyyyB______","_____BBBB_______","________________"],
    yoshi_body: ["______GGGGGG____","____GGGGGGGGGG__","___GGGGGGGGGGGG_","__GGGwGGGGGGGG__","__GGwwwGGGGGGG__","__GGGwGGGGGGGG__","__GGGGGGGGGGGG__","__GGGGwwwwwGGG__","__GGGGGGGGGGGG__","___GGGGGGGGGG___","___GGGGGGGGGG___","___GGGG__GGGG___","__GGGG____GGGG__","__O__O____O__O__","__OOOO____OOOO__","________________"],
    yoshi_head: ["____GGGGG_______","___GwwwwwG______","___GwwBwwG______","___GwwwwwG______","___GGGGGGGGG____","___GGGGGGGGGGG__","____GGGGGGGGGG__","____GGGGGGGG____","_____GGGGG______","_____GGGGG______","______e_________","________________"],
    flag_ball:  ["____GGGG____","___GGGGGG___","___GGGGGG___","____GGGG____"],
    castle_brick: ["CCCCCCCCCCCCCCCC","CccCccCccCccCccC","CccCccCccCccCccC","CCCCCCCCCCCCCCCC","ccCccCccCccCccCc","ccCccCccCccCccCc","CCCCCCCCCCCCCCCC","CccCccCccCccCccC","CccCccCccCccCccC","CCCCCCCCCCCCCCCC","ccCccCccCccCccCc","ccCccCccCccCccCc","CCCCCCCCCCCCCCCC","CccCccCccCccCccC","CccCccCccCccCccC","CCCCCCCCCCCCCCCC"],
    castle_top: ["________________","________________","_CC__CC__CC__CC_","_CC__CC__CC__CC_","CCCCCCCCCCCCCCCC","CCCCCCCCCCCCCCCC","CCCCCCCCCCCCCCCC","CCCCCCCCCCCCCCCC","CccCccCccCccCccC","CccCccCccCccCccC","CCCCCCCCCCCCCCCC","ccCccCccCccCccCc","ccCccCccCccCccCc","CCCCCCCCCCCCCCCC","CccCccCccCccCccC","CccCccCccCccCccC"],
    castle_door: ["__CCCCCCCCCCCC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__","__CddddddddddC__"]
};

const CFG = { TILE: 32, GRAV: 0.8, ACCEL: 0.5, FRIC: 0.8, MAX_SPD: 7, JUMP: -15 };
const AssetCache = {};

function getSprite(name, modifier = null) {
    const key = name + (modifier || '');
    if (AssetCache[key]) return AssetCache[key];
    const data = SPRITES[name];
    if (!data) return document.createElement('canvas'); 
    const cvs = document.createElement('canvas');
    cvs.width = 32; cvs.height = 32;
    const ctx = cvs.getContext('2d');
    const ps = 2; 
    data.forEach((row, y) => {
        for (let x = 0; x < row.length; x++) {
            let char = row[x];
            let color = PALETTE[char] || char;
            if (modifier === 'luigi') { if (char === 'r') color = PALETTE['g']; if (char === 'R') color = PALETTE['G']; }
            if (modifier === 'fire') { if (char === 'r') color = '#ffffff'; if (char === 'o') color = '#d22020'; }
            if (color && color !== PALETTE._) { ctx.fillStyle = color; ctx.fillRect(x * ps, y * ps, ps, ps); }
        }
    });
    AssetCache[key] = cvs;
    return cvs;
}

/**
 * ==========================================
 * 2. ENTIDADES
 * ==========================================
 */

class Entity {
    constructor(x, y, w, h, id = -1) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.vx = 0; this.vy = 0;
        this.dead = false; this.grounded = false;
        this.id = id; 
    }
    
    resolve(game) {
        this.x += this.vx;
        let cx = this.col(game);
        if(cx) {
            if(this.vx > 0) this.x = cx.x*CFG.TILE - this.w;
            else if(this.vx < 0) this.x = (cx.x+1)*CFG.TILE;
            this.vx = 0;
        }
        this.y += this.vy;
        this.grounded = false;
        let cy = this.col(game);
        if(cy) {
            if(this.vy > 0) { this.y = cy.y*CFG.TILE - this.h; this.grounded = true; }
            else if(this.vy < 0) { this.y = (cy.y+1)*CFG.TILE; if(this instanceof Player) this.hit(game, cy.x, cy.y); }
            this.vy = 0;
        }
    }

    col(game) {
        const l = Math.floor(this.x/CFG.TILE), r = Math.floor((this.x+this.w-0.1)/CFG.TILE);
        const t = Math.floor(this.y/CFG.TILE), b = Math.floor((this.y+this.h-0.1)/CFG.TILE);
        for(let y=t; y<=b; y++) for(let x=l; x<=r; x++) { if(game.map[y*game.mapW+x]) return {x,y}; }
        return null;
    }
    draw(ctx) {}
    update(game) {}
}

class Player extends Entity {
    constructor(x, y, skin) {
        super(x, y, 28, 28);
        this.skin = skin;
        this.mode = 'small'; 
        this.facing = 1;
        this.riding = false;
        this.animState = 'idle';
        this.score = 0;
        this.lives = 5;
        this.lastShot = 0;
        this.isRemote = false;
        this.hasFinished = false;
        this.invul = false;
        this.canDoubleJump = false;
        this.jumpHeld = false;
    }

    update(keys, game) {
        if(this.isRemote || this.hasFinished) return;

        // Se estiver focado no chat, não move
        if(document.activeElement === document.getElementById('chat-input')) {
            this.vx = 0; return;
        }

        const acc = this.riding ? 0.8 : CFG.ACCEL;
        if(keys.a) { this.vx -= acc; this.facing = -1; }
        else if(keys.d) { this.vx += acc; this.facing = 1; }
        else this.vx *= CFG.FRIC;
        this.vx = Math.max(Math.min(this.vx, CFG.MAX_SPD), -CFG.MAX_SPD);

        const jumpPressed = keys.w || keys.space;
        if (this.grounded) {
            this.canDoubleJump = true; 
            if (jumpPressed && !this.jumpHeld) {
                this.vy = this.riding ? CFG.JUMP - 3 : CFG.JUMP;
                this.grounded = false;
                this.jumpHeld = true;
            }
        } else {
            if (jumpPressed && !this.jumpHeld && this.canDoubleJump) {
                this.vy = (this.riding ? CFG.JUMP - 3 : CFG.JUMP) * 0.9; 
                this.canDoubleJump = false; 
                this.jumpHeld = true;
            }
        }
        if (!jumpPressed) this.jumpHeld = false;

        if(keys.shift && this.mode === 'fire' && !this.riding) this.shootFireball(game);

        if(keys.e && this.riding) {
            this.riding = false; this.y -= 10;
            const yoshi = new Item(this.x + 50 * this.facing, this.y, 'yoshi');
            game.entities.push(yoshi);
            if(game.mode === 'multi') game.syncSpawn(yoshi);
        }

        this.vy += CFG.GRAV;
        this.resolve(game);
        
        if(this.y > game.canvas.height) this.die();

        game.entities.forEach(e => { if(this.overlap(e)) this.handleEnt(e, game); });

        if(!this.grounded) this.animState = 'jump';
        else if(Math.abs(this.vx) > 0.5) this.animState = 'run';
        else this.animState = 'idle';
    }

    shootFireball(game) {
        const now = Date.now();
        if(now - this.lastShot > 400) {
            const fb = new Fireball(this.x + (this.facing*20), this.y, this.facing);
            game.entities.push(fb);
            this.lastShot = now;
        }
    }

    die() {
        if (this.lives > 0) {
            this.lives--;
            this.x = 100; this.y = 300; this.vx = 0; this.vy = 0;
            this.mode = 'small'; this.riding = false;
            this.invul = true; setTimeout(() => this.invul = false, 3000); 
            this.canDoubleJump = true; 
        } else {
            Game.ins.endGame(false);
        }
    }

    hit(game, tx, ty) {
        const idx = ty*game.mapW+tx;
        const t = game.map[idx];
        if(t === 3) { 
            game.updateMap(idx, 99); 
            this.spawnLoot(game, tx, ty);
            this.score += 200;
        } else if (t === 2 && (this.mode !== 'small' || this.riding)) {
            game.updateMap(idx, 0); 
            this.score += 50;
        }
    }

    spawnLoot(game, tx, ty) {
        let type = 'mushroom';
        const rand = Math.random();
        if (rand < 0.2) type = 'yoshi'; 
        else if (this.mode === 'small') type = 'mushroom';
        else type = 'flower';
        
        const item = new Item(tx*CFG.TILE, (ty-1)*CFG.TILE, type);
        game.entities.push(item);
        if(game.mode === 'multi') game.syncSpawn(item);
    }

    handleEnt(e, game) {
        if (e instanceof Item) {
            game.killEntity(e.id);
            this.score += 1000;
            if(e.type === 'yoshi') this.riding = true;
            else if(e.type === 'mushroom' && this.mode === 'small') { this.mode = 'big'; this.y -= 10; this.h = 40; }
            else if(e.type === 'flower') { this.mode = 'fire'; this.h = 40; }
        } else if (e instanceof Goomba) {
            if(this.vy > 0 && this.y + this.h < e.y + e.h/2) { 
                game.killEntity(e.id);
                this.vy = -8; this.score += 100; 
                this.canDoubleJump = true; 
            } 
            else if (!this.riding && !this.invul) {
                if(this.mode === 'small') this.die();
                else { this.mode = 'small'; this.h = 28; this.invul = true; setTimeout(() => this.invul = false, 2000); }
            }
        } else if (e instanceof Flagpole) {
            if(!this.hasFinished) { this.hasFinished = true; this.score += 5000; this.vx = 0; }
        }
    }

    overlap(e) { return (this.x < e.x + e.w && this.x + this.w > e.x && this.y < e.y + e.h && this.y + this.h > e.y); }

    draw(ctx) {
        if(this.invul && Game.ins.frame % 10 < 5) return;
        if(this.hasFinished && Game.ins.mode === 'single') return; 

        let mod = this.skin;
        if(this.mode === 'fire') mod = 'fire';
        let img = getSprite('mario_' + this.animState, mod);
        
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        ctx.scale(this.facing, 1);
        
        if(this.riding) {
            const yBody = getSprite('yoshi_body');
            const yHead = getSprite('yoshi_head');
            ctx.drawImage(yBody, -16, -10);
            ctx.drawImage(yHead, 10, -25); 
            ctx.drawImage(img, -10, -25, 24, 24); 
        } else {
            if(this.mode !== 'small') ctx.drawImage(img, -16, -26, 32, 52); 
            else ctx.drawImage(img, -16, -16);
        }
        ctx.restore();
    }
}

class Goomba extends Entity {
    constructor(x,y, id) { super(x,y,32,32, id); this.vx = -1.5; }
    update(game) {
        this.vy += CFG.GRAV;
        this.resolve(game);
        if(this.vx===0) this.vx *= -1;
    }
    draw(ctx) {
        const w = Math.sin(Date.now()/100) * 2;
        ctx.drawImage(getSprite('goomba'), this.x, this.y + w);
    }
}

class Item extends Entity {
    constructor(x, y, type, id) { super(x, y, 32, 32, id); this.type = type; this.vx = (type === 'mushroom') ? 2 : 0; this.vy = -5; }
    update(game) {
        this.vy += CFG.GRAV; this.resolve(game);
        if(this.grounded && this.type === 'mushroom') this.vx = 2;
    }
    draw(ctx) {
        if(this.type === 'yoshi') ctx.drawImage(getSprite('yoshi_head'), this.x, this.y);
        else if(this.type === 'flower') ctx.drawImage(getSprite('flower'), this.x, this.y);
        else ctx.drawImage(getSprite('mushroom'), this.x, this.y);
    }
}

class Fireball extends Entity {
    constructor(x, y, dir) { super(x, y, 16, 16); this.vx = dir * 7; this.vy = 2; }
    update(game) {
        this.vy += CFG.GRAV; this.x += this.vx; this.y += this.vy;
        const c = this.col(game);
        if(c) { if(this.vy > 0) this.vy = -6; else this.dead = true; }
        game.entities.forEach(e => {
            if(e instanceof Goomba && this.overlap(e)) { 
                game.killEntity(e.id);
                this.dead = true; Game.ins.localPlayer.score += 50; 
            }
        });
        if(this.y > game.canvas.height) this.dead = true;
    }
    overlap(e) { return (this.x < e.x+e.w && this.x+this.w > e.x && this.y < e.y+e.h); }
    draw(ctx) { ctx.drawImage(getSprite('fireball'), this.x, this.y); }
}

class Flagpole extends Entity {
    constructor(x,y) { super(x,y,20, 320); } 
    draw(ctx) {
        ctx.fillStyle = "#00aa00"; ctx.fillRect(this.x+8, this.y, 4, 320);
        ctx.drawImage(getSprite('flag_ball'), this.x, this.y);
    }
}

/**
 * ==========================================
 * 3. ENGINE PRINCIPAL
 * ==========================================
 */
class Engine {
    constructor(mode, role, conn) {
        this.canvas = document.getElementById('ctx');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.mode = mode;
        this.role = role;
        this.conn = conn;
        this.frame = 0;
        this.time = 400; 
        this.gameState = 'play'; 
        this.nextEntId = 1000; 

        this.setup();
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
        
        this.timerInt = setInterval(() => { 
            if(this.gameState === 'play') { this.time--; if(this.time <= 0) this.localPlayer.die(); }
        }, 1000);
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.ctx.imageRendering = 'pixelated';
    }

    setup() {
        this.map = []; 
        this.mapW = 400; 
        this.mapH = 20;  
        this.cameraX = 0;
        this.entities = [];
        
        this.genLevel();

        this.localPlayer = new Player(100, 300, this.role === 'host' ? 'mario' : 'luigi');
        this.players = [this.localPlayer];

        if (this.mode === 'multi') {
            this.remotePlayer = new Player(-100, -100, this.role === 'host' ? 'luigi' : 'mario');
            this.remotePlayer.isRemote = true;
            this.players.push(this.remotePlayer);
        }

        this.keys = { w:false, a:false, s:false, d:false, shift:false, space:false, e:false };
        window.onkeydown = e => this.key(e, true);
        window.onkeyup = e => this.key(e, false);
    }

    key(e, s) {
        const k = e.key.toLowerCase();
        if(['w','arrowup'].includes(k)) this.keys.w = s;
        if(['a','arrowleft'].includes(k)) this.keys.a = s;
        if(['s','arrowdown'].includes(k)) this.keys.s = s;
        if(['d','arrowright'].includes(k)) this.keys.d = s;
        if(k === 'shift') this.keys.shift = s;
        if(k === ' ') this.keys.space = s;
        if(k === 'e') this.keys.e = s;
    }

    fireAction() { if(this.localPlayer.mode === 'fire') this.localPlayer.shootFireball(this); }

    updateMap(idx, val) {
        this.map[idx] = val; 
        if (this.mode === 'multi' && this.conn && this.conn.open) {
            this.conn.send({ type: 'map', idx: idx, val: val }); 
        }
    }

    killEntity(id) {
        const ent = this.entities.find(e => e.id === id);
        if (ent) ent.dead = true; 
        if (this.mode === 'multi' && this.conn && this.conn.open) {
            this.conn.send({ type: 'kill', id: id }); 
        }
    }

    syncSpawn(ent) {
        if(!ent.id) ent.id = this.nextEntId++;
        if (this.conn && this.conn.open) {
            this.conn.send({ type: 'spawn', x: ent.x, y: ent.y, k: ent.type, id: ent.id });
        }
    }

    genLevel() {
        this.map = new Array(this.mapW * this.mapH).fill(0);
        const set = (x,y,t) => { if(x<this.mapW && y<this.mapH) this.map[y*this.mapW+x] = t; };
        const rect = (x,y,w,h,t) => { for(let i=0;i<w;i++) for(let j=0;j<h;j++) set(x+i, y+j, t); };

        const FLOOR = 15;
        rect(0, FLOOR, 300, 5, 1);
        
        const pits = [69, 86, 110, 135, 153];
        pits.forEach(p => rect(p, FLOOR, 3, 5, 0));

        set(16, FLOOR-4, 3);
        rect(20, FLOOR-4, 5, 1, 2); 
        set(21, FLOOR-4, 3); set(22, FLOOR-8, 3);

        [[28,2], [38,3], [46,4], [57,4], [100, 5], [163,2], [179,2]].forEach(p => {
            rect(p[0], FLOOR-p[1], 2, p[1], 5); rect(p[0], FLOOR-p[1], 2, 1, 4);
        });

        let eId = 0;
        const addG = (x) => this.entities.push(new Goomba(x*CFG.TILE, (FLOOR-2)*CFG.TILE, eId++));

        [22, 25, 40, 42].forEach(addG);

        rect(60, FLOOR-4, 3, 1, 2); rect(65, FLOOR-6, 3, 1, 2);
        this.entities.push(new Goomba(61*CFG.TILE, (FLOOR-5)*CFG.TILE, eId++));
        this.entities.push(new Goomba(66*CFG.TILE, (FLOOR-7)*CFG.TILE, eId++));

        rect(75, FLOOR-4, 1, 1, 2); set(76, FLOOR-4, 3); rect(77, FLOOR-4, 1, 1, 2);
        [80, 82, 84].forEach(addG);
        rect(80, FLOOR-8, 8, 1, 2); rect(91, FLOOR-8, 3, 1, 2); set(94, FLOOR-8, 3);

        rect(108, FLOOR-5, 7, 1, 2);
        set(111, FLOOR-9, 3); set(112, FLOOR-9, 3); set(113, FLOOR-9, 3);
        this.entities.push(new Goomba(110*CFG.TILE, (FLOOR-6)*CFG.TILE, eId++));

        [120, 122, 125, 127, 130].forEach(addG);

        rect(134, FLOOR-4, 1, 1, 2); rect(136, FLOOR-4, 1, 1, 2); set(135, FLOOR-7, 3);

        [145, 147, 150, 158, 160].forEach(addG);

        const endX = 190;
        for(let i=0; i<8; i++) rect(endX+i, FLOOR-1-i, 1, 1+i, 99); 
        rect(endX+9, FLOOR-1, 1, 1, 99); 

        // MASTRO DA BANDEIRA (FINAL)
        const flagX = endX + 16;
        this.entities.push(new Flagpole(flagX*CFG.TILE, (FLOOR-10)*CFG.TILE));
        
        const cX = flagX + 6; const cY = FLOOR - 5;
        rect(cX, cY, 5, 5, 6); rect(cX, cY-2, 5, 2, 7); set(cX+2, FLOOR-1, 8); set(cX+2, FLOOR-2, 8); 
        
        rect(this.mapW-2, 0, 1, this.mapH, 99); 
    }

    update() {
        if(this.gameState === 'gameover' || this.gameState === 'win') return;

        document.getElementById('score-val').innerText = this.localPlayer.score.toString().padStart(6,'0');
        document.getElementById('time-val').innerText = this.time;
        document.getElementById('lives-val').innerText = this.localPlayer.lives;
        
        const btnFire = document.getElementById('btn-fire');
        if(this.localPlayer.mode === 'fire') btnFire.classList.remove('hidden');
        else btnFire.classList.add('hidden');

        const yHint = document.getElementById('yoshi-hint');
        if(this.localPlayer.riding) yHint.classList.add('visible');
        else yHint.classList.remove('visible');

        this.localPlayer.update(this.keys, this);
        this.entities.forEach(e => e.update(this));
        this.entities = this.entities.filter(e => !e.dead);

        let targetX = this.localPlayer.x - this.canvas.width * 0.4;
        if (targetX < 0) targetX = 0;
        if (targetX > this.mapW * CFG.TILE - this.canvas.width) targetX = this.mapW * CFG.TILE - this.canvas.width;
        this.cameraX += (targetX - this.cameraX) * 0.1;

        if (this.mode === 'multi' && this.conn && this.conn.open) {
            this.conn.send({
                type: 'player',
                x: this.localPlayer.x, y: this.localPlayer.y,
                vx: this.localPlayer.vx, vy: this.localPlayer.vy,
                f: this.localPlayer.facing, s: this.localPlayer.animState,
                r: this.localPlayer.riding, m: this.localPlayer.mode,
                lives: this.localPlayer.lives,
                finished: this.localPlayer.hasFinished
            });

            if(this.localPlayer.hasFinished && this.remotePlayer.hasFinished) {
                this.endGame(true);
            } else if (this.localPlayer.hasFinished && this.gameState !== 'wait') {
                this.gameState = 'wait';
                this.showWaitScreen();
            }
        } else if (this.mode === 'single' && this.localPlayer.hasFinished) {
            this.endGame(true);
        }

        this.frame++;
    }

    showWaitScreen() {
        const scr = document.getElementById('screen-result');
        scr.classList.remove('hidden');
        document.getElementById('result-msg').innerText = "CASTLE REACHED";
        document.getElementById('result-sub').innerText = "VOCÊ CHEGOU!";
        document.getElementById('wait-msg').classList.remove('hidden');
        document.getElementById('btn-restart').style.display = 'none'; 
    }

    endGame(win) {
        this.gameState = win ? 'win' : 'gameover';
        const scr = document.getElementById('screen-result');
        const tit = document.getElementById('result-msg');
        const sub = document.getElementById('result-sub');
        const wait = document.getElementById('wait-msg');
        const btn = document.getElementById('btn-restart');
        
        scr.classList.remove('hidden');
        wait.classList.add('hidden'); 
        btn.style.display = 'inline-block';

        if(win) {
            tit.innerText = this.mode === 'multi' ? "TEAM VICTORY!" : "COURSE CLEAR!";
            tit.style.color = "#ffcc00";
            sub.innerText = "PONTUAÇÃO: " + this.localPlayer.score;
        } else {
            tit.innerText = "GAME OVER";
            tit.style.color = "#cc0000";
            sub.innerText = "TENTE NOVAMENTE";
        }
    }

    draw() {
        this.ctx.fillStyle = '#5c94fc';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.save();
        this.ctx.translate(-Math.floor(this.cameraX), 0);

        const startX = Math.floor(this.cameraX / CFG.TILE);
        const endX = startX + (this.canvas.width / CFG.TILE) + 2;

        for (let y = 0; y < this.mapH; y++) {
            for (let x = startX; x <= endX; x++) {
                const t = this.map[y * this.mapW + x];
                if (!t) continue;
                
                const px = x * CFG.TILE;
                const py = y * CFG.TILE;

                if (t===1) { 
                    this.ctx.fillStyle = '#c84c0c'; this.ctx.fillRect(px,py,32,32);
                    this.ctx.fillStyle = '#fdb17d'; this.ctx.fillRect(px+4,py,10,6);
                }
                else if (t===2) this.ctx.drawImage(getSprite('brick'), px, py);
                else if (t===3) this.ctx.drawImage(getSprite('qblock'), px, py);
                else if (t===4) { 
                    this.ctx.fillStyle = '#00aa00'; this.ctx.fillRect(px,py,32,32);
                    this.ctx.lineWidth=2; this.ctx.strokeStyle='#004400'; this.ctx.strokeRect(px,py,32,32);
                } 
                else if (t===5) { 
                    this.ctx.fillStyle = '#00aa00'; this.ctx.fillRect(px+2,py,28,32);
                }
                else if (t===99) { 
                    this.ctx.fillStyle = '#b85c1c'; this.ctx.fillRect(px,py,32,32);
                    this.ctx.strokeStyle = '#000'; this.ctx.strokeRect(px,py,32,32);
                }
                else if (t===6) this.ctx.drawImage(getSprite('castle_brick'), px, py);
                else if (t===7) this.ctx.drawImage(getSprite('castle_top'), px, py);
                else if (t===8) this.ctx.drawImage(getSprite('castle_door'), px, py);
            }
        }

        this.entities.forEach(e => e.draw(this.ctx));
        this.players.forEach(p => p.draw(this.ctx));

        this.ctx.restore();
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

/**
 * ==========================================
 * 4. REDE, CHAT E MENU
 * ==========================================
 */

const Chat = {
    handleInput: (e) => {
        e.stopPropagation(); // Impede andar com WASD
        if(e.key === 'Enter') {
            const input = document.getElementById('chat-input');
            const msg = input.value.trim();
            if(msg && Network.conn && Network.conn.open) {
                // Envia
                Network.conn.send({ type: 'chat', msg: msg });
                Chat.addMsg(msg, 'p1');
            }
            input.value = '';
            // Tira foco para voltar a andar
            document.getElementById('game-container').focus();
            input.blur();
        }
    },
    addMsg: (txt, origin) => {
        const box = document.getElementById('chat-messages');
        const div = document.createElement('div');
        div.className = 'chat-msg ' + (origin === 'p1' ? 'chat-p1' : 'chat-p2');
        div.innerText = (origin === 'p1' ? 'Eu: ' : 'Amigo: ') + txt;
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
    }
};

const Network = {
    peer: null, conn: null,
    init: () => {
        Network.peer = new Peer();
        Network.peer.on('open', id => {
            document.getElementById('p2p-loading').classList.add('hidden');
            document.getElementById('p2p-ready').classList.remove('hidden');
            document.getElementById('my-id').value = id;
        });
        Network.peer.on('connection', c => {
            Network.conn = c;
            Game.start('multi', 'host', c);
        });
    },
    connect: () => {
        const id = document.getElementById('friend-id').value;
        if(!id) return alert("Insira ID!");
        const c = Network.peer.connect(id);
        c.on('open', () => Game.start('multi', 'client', c));
        c.on('data', d => {
            if(!Game.ins) return;

            if (d.type === 'player') {
                if(Game.ins.remotePlayer) {
                    const p = Game.ins.remotePlayer;
                    p.x=d.x; p.y=d.y; p.facing=d.f; p.animState=d.s; p.riding=d.r; p.mode=d.m;
                    p.lives=d.lives; p.hasFinished=d.finished;
                }
            } else if (d.type === 'map') {
                Game.ins.map[d.idx] = d.val;
            } else if (d.type === 'kill') {
                const ent = Game.ins.entities.find(e => e.id === d.id);
                if(ent) ent.dead = true;
            } else if (d.type === 'spawn') {
                const it = new Item(d.x, d.y, d.k, d.id);
                Game.ins.entities.push(it);
            } else if (d.type === 'chat') {
                Chat.addMsg(d.msg, 'p2');
            }
        });
    }
};

const Menu = {
    showMulti: () => {
        document.getElementById('menu-main').classList.add('hidden');
        document.getElementById('menu-multi').classList.remove('hidden');
        Network.init();
    },
    showControls: () => {
        document.getElementById('menu-main').classList.add('hidden');
        document.getElementById('menu-controls-screen').classList.remove('hidden');
    },
    hideControls: () => {
        document.getElementById('menu-controls-screen').classList.add('hidden');
        document.getElementById('menu-main').classList.remove('hidden');
    },
    copyId: () => {
        const id = document.getElementById('my-id');
        id.select();
        navigator.clipboard.writeText(id.value).then(() => alert("ID Copiado!"));
    }
};

const Game = {
    ins: null,
    start: (m, r='host', c=null) => {
        document.querySelectorAll('.ui-layer').forEach(e => e.classList.add('hidden'));
        document.getElementById('hud').classList.remove('hidden');
        document.getElementById('lives-hud').classList.remove('hidden');
        
        if(m === 'multi') document.getElementById('chat-ui').classList.remove('hidden');

        Game.ins = new Engine(m, r, c);
        if(c) c.on('data', d => {
            if(!Game.ins) return;
            if (d.type === 'player') {
                if(Game.ins.remotePlayer) {
                    const p = Game.ins.remotePlayer;
                    p.x=d.x; p.y=d.y; p.facing=d.f; p.animState=d.s; p.riding=d.r; p.mode=d.m;
                    p.lives=d.lives; p.hasFinished=d.finished;
                }
            } else if (d.type === 'map') {
                Game.ins.map[d.idx] = d.val;
            } else if (d.type === 'kill') {
                const ent = Game.ins.entities.find(e => e.id === d.id);
                if(ent) ent.dead = true;
            } else if (d.type === 'spawn') {
                const it = new Item(d.x, d.y, d.k, d.id);
                Game.ins.entities.push(it);
            } else if (d.type === 'chat') {
                Chat.addMsg(d.msg, 'p2');
            }
        });
    },
    fireAction: () => { if(Game.ins) Game.ins.fireAction(); }
};
</script>
</body>
</html>
